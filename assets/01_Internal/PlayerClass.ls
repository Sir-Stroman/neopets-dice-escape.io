property pWorld, pmodel, pReferenceNode, pRotating, pTotalRotation, pDir, pSpeed, pX, pZ, pMap, pTileSize, pNumRows, pNumCols, pFace, deleteMe, pdead, pcurrenttileglobal gGame, gActors, gCameraScript, gScoreboardon new me, gameWorld, currentMap, tileSize, faceup  deleteMe = 0  pWorld = gameWorld  pMap = currentMap  pRotating = 0  pDir = "nothing"  pSpeed = 6  pdead = 0  pNumRows = gGame.getNumRows()  pNumCols = gGame.getNumCols()  pTileSize = tileSize  pmodel = pWorld.model("playerPiece")  pReferenceNode = pWorld.model("nullObj")  pReferenceNode.visibility = #none  case faceup of    1:      v = vector(90, 0, 180)    2:      v = vector(0, 0, 180)    3:      v = vector(0, 0, 90)    4:      v = vector(0, 0, -90)    5:      v = vector(0, 0, 0)    6:      v = vector(90, 90, 0)  end case  pmodel.rotate(v)  pFace = me.determineFacing()  gActors.append(me)  return meendon stopStepFrame me  deleteMe = 1endon death me  pdead = 1  sound(1).play(member("deathSound", "sounds"))endon setRotationVars me  case pDir of    "left":      pX = 0      pZ = pSpeed    "right":      pX = 0      pZ = -pSpeed    "up":      pZ = 0      pX = -pSpeed    "down":      pZ = 0      pX = pSpeed    otherwise:      pX = 0      pZ = 0  end caseendon placeNullObj me  boxPos = pmodel.worldPosition  tileSize = pmodel.resource.height  case pDir of    "left":      xEdge = boxPos.x - (tileSize / 2)      zEdge = boxPos.z    "right":      xEdge = boxPos.x + (tileSize / 2)      zEdge = boxPos.z    "up":      xEdge = boxPos.x      zEdge = boxPos.z - (tileSize / 2)    "down":      xEdge = boxPos.x      zEdge = boxPos.z + (tileSize / 2)    otherwise:      nothing()  end case  boxBottom = boxPos.y - (tileSize / 2)  pReferenceNode.worldPosition = vector(xEdge, boxBottom, zEdge)endon checkGrid me, Dir  pos = pmodel.worldPosition  tileX = integer(pos.x / pTileSize) + 1  tileZ = integer(pos.z / pTileSize) + 1  case Dir of    "left":      tileX = tileX - 1    "right":      tileX = tileX + 1    "up":      tileZ = tileZ - 1    "down":      tileZ = tileZ + 1  end case  if (tileX = 0) or (tileZ = 0) then    return 0  else    if (tileX > pNumCols) or (tileZ > pNumRows) then      return 0    else      Tile = pMap[tileZ][tileX]      if Tile = VOID then        return 0      end if      walkeable = Tile.getWalkeable()      return walkeable    end if  end ifendon getcurrenttile me  return pcurrenttileendon checkCurrentTile me  pos = pmodel.worldPosition  tileX = integer(pos.x / pTileSize) + 1  tileZ = integer(pos.z / pTileSize) + 1  pcurrenttile = pWorld.model("tile_" & tileZ & "-" & tileX)  gGame.dieOnGridLoc(tileZ, tileX)endon getKeys me  if keyPressed(123) then    next_dir = "left"  else    if keyPressed(124) then      next_dir = "right"    else      if keyPressed(125) then        next_dir = "down"      else        if keyPressed(126) then          next_dir = "up"        else          next_dir = "nothing"        end if      end if    end if  end if  if next_dir <> "nothing" then    nextGridSpot = me.checkGrid(next_dir)    if (nextGridSpot <> 2) and (nextGridSpot <> 4) and (nextGridSpot <> VOID) and (nextGridSpot <> 0) then      pDir = next_dir    else      pDir = "nothing"    end if  else    pDir = "nothing"  end ifendon determineFacing me  gGame.pWorld.group("nonCollide").removeFromWorld()  v = vector(0.000001, 0.99999990000000005, 0.000001)  modelPos = vector(pmodel.transform.position.x, pmodel.transform.position.y - 100, pmodel.transform.position.z)  modelList = pWorld.modelsUnderRay(modelPos, v, 2, #detailed)  max = modelList.count  repeat with x = 1 to max    m = modelList[x].model.name    if m = "playerPiece" then      faceIDNUM = modelList[x].meshID    end if  end repeat  gGame.pWorld.group("nonCollide").addToWorld()  case faceIDNUM of    1:      diceResult = 1    5:      diceResult = 2    4:      diceResult = 3    2:      diceResult = 4    6:      diceResult = 5    3:      diceResult = 6  end case  return diceResultendon getFace me  return pFaceendon dodeathanim me  pmodel.transform.scale = vector(0.90000000000000002, 0.90000000000000002, 0.90000000000000002)  y_pos = pmodel.transform.position.y  y_pos = y_pos - 1  pmodel.transform.position.y = y_pos  if y_pos < (-pTileSize / 2) then    gGame.playerdeath()  end ifendon step me  if pdead = 1 then    me.dodeathanim()    return   end if  me.getKeys()  if pRotating = 0 then    if pDir <> "nothing" then      pRotating = 1      me.placeNullObj()      me.setRotationVars()    end if  end if  if pRotating = 1 then    rotationVector = vector(pX, 0, pZ)    pRotation = pRotation + rotationVector    pmodel.rotate(rotationVector, pReferenceNode)    pTotalRotation = pTotalRotation + pSpeed    if (pTotalRotation mod 90) = 0 then      sound(1).play(member("playerMoveSound", "sounds"))      gGame.deductRoundScore()      pFace = me.determineFacing()      me.checkCurrentTile()      pRotating = 0    end if  end ifend