property pWorld, pmodel, pMapList, pBoard, pNumRows, pNumCols, pTileSize, pRoundScore, pTimeBonus, pScore, pLevel, pMaxLevels, plives, pPlayer, pExitTile, pTimer, pTimeLimit, pActors, pSpikeList, p3dworldy, movieWidth, movieHeight, pprompt, cameraNull, pSpriteChannelNum, pdietexture, pplainwhitetexture, pgroundtexture, ptriggertexture, pfalltiletexture, pwoodtexture, pdeathtiletexture, pcointexture5, pcointexture10, pcointexture25, pdieface1, pdieface2, pdieface3, pdieface4, pdieface5, pdieface6, myCheats, myCheat, pCameraMode, pTimerCheated, pHelpMe, pFlipX, pFlipZglobal _DGSBIOS, gDrawWireMode, ggameover, gshowretry, grounddone, gCameraScript, gScoreboardon new me, die_tex, white_tex, ground_tex, trigger_tex, fall_tex, wood_tex, deathtile_tex, coin_tex5, coin_tex10, coin_tex25, die1, die2, die3, die4, die5, die6  pdietexture = die_tex  pplainwhitetexture = white_tex  pgroundtexture = ground_tex  ptriggertexture = trigger_tex  pfalltiletexture = fall_tex  pwoodtexture = wood_tex  pdeathtiletexture = deathtile_tex  pcointexture5 = coin_tex5  pcointexture10 = coin_tex10  pcointexture25 = coin_tex25  pdieface1 = die1  pdieface2 = die2  pdieface3 = die3  pdieface4 = die4  pdieface5 = die5  pdieface6 = die6  ggameover = 0  gDrawWireMode = 0  pHelpMe = 0  movieWidth = 480  movieHeight = 460  me.Initialize()  return meendon Initialize me  pBoard = []  pMapList = []  pActors = []  pCameraMode = "iso"  pTimerCheated = 0  myCheat = EMPTY  myCheats = []  myCheats.add(["topdown", "me.toggleCameraView()"])  myCheats.add(["moretimeruki", "me.resetTimer()"])  myCheats.add(["helpmeplease", "me.resetTimer()"])  myCheats.add(["flybywire", "me.toggleWireframe()"])  pLevel = 0  pMaxLevels = 0  pScore = 0  plives = 3  pTimeLimit = 60000  p3dworldy = 100  r = random(100)  if r > 90 then    pFlipX = 1  else    pFlipX = 0  end if  pWorld = member("blank3D", "3d Cast")endon setdiefacetextures me  repeat with x = 1 to 6    source_img = value("pDieFace" & x)    diefaceshader = pWorld.newShader("faceShader_" & x, #standard)    diefacetexture = pWorld.newTexture("face_" & x, #fromImageObject, source_img)    diefaceshader.texture = diefacetexture  end repeatendon checkCheat me, c  me.myCheat = me.myCheat & c  len = length(me.myCheat)  bFound = 0  repeat with aCheat in me.myCheats    if chars(me.myCheat, 1, len) = chars(aCheat[1], 1, len) then      bFound = 1      if me.myCheat = aCheat[1] then        do(aCheat[2])        me.myCheat = EMPTY        exit repeat      end if    end if  end repeat  if bFound = 0 then    me.myCheat = c  end ifendon getTimeBonus me  return pTimeBonusendon setExitTile me, Tile  pExitTile = Tileendon getExitTile me  return pExitTileendon getNumRows me  return pNumRowsendon getNumCols me  return pNumColsendon addMap me, mapText  pMapList.append(mapText)  pMaxLevels = pMapList.countendon getTimeLimit me  return pTimeLimitendon getNumSecondsLeft me  return pTimer.getNumSecondsLeft()endon playergetcoin me, coin_val  me.changeScoreBy(coin_val)endon getScore me  return pScoreendon getlives me  return plivesendon changeScoreBy me, num  pScore = pScore + num  gScoreboard.updateScore()endon getLevel me  return pLevelendon getRoundScore me  return pRoundScoreendon deductRoundScore me  pRoundScore = pRoundScore - 4  if pRoundScore < 0 then    pRoundScore = 0  end if  gScoreboard.updateroundscore()endon timeOver me  pPlayer.death()endon dieOnGridLoc me, z, x  pBoard[z][x].dieOnGridLoc(pPlayer)endon getmap me  if pLevel <= pMapList.count then    mapNum = pLevel  else    mapNum = pMapList.count  end if  level_map = value(pMapList[mapNum])  return level_mapendon nextLevel me  put "pMaxLevels" && pMaxLevels  grounddone = 0  pSpikeList = []  if pLevel >= pMaxLevels then    me.setEndGameText("beat_all")    me.gameover()    me.stopActors()    me.gameover()    me.endgame()    go("gameoverframe")    return   end if  if gCameraScript <> VOID then    gCameraScript.stopStep()  end if  pLevel = pLevel + 1  _DGSBIOS.sendGameTag("Reached Level" && string(pLevel))  level_map = me.getmap()  me.setupBoard(level_map)endon endLevel me  pTimer.Remove()endon startGame me  _DGSBIOS.sendGameTag("Game Started")  me.nextLevel()endon stopActors me  max = pActors.count  repeat with x = 1 to max    pActors[x].stopStepFrame()  end repeat  pActors = []endon getplayercurrenttile me  return pPlayer.getcurrenttile()endon makePlayer me, currentMap, pZ, pX, die_face_up  dieModel = pWorld.newModel("playerPiece", pWorld.modelResource("die_cube"))  dieshader = pWorld.newShader("dieShader", #standard)  dietexture = pWorld.newTexture("die_texture", #fromImageObject, pdietexture)  dieshader.texture = dietexture  dieModel.shaderList = dieshader  dieModel.shaderList[1] = pWorld.shader("faceShader_6")  dieModel.shaderList[2] = pWorld.shader("faceShader_3")  dieModel.shaderList[3] = pWorld.shader("faceShader_1")  dieModel.shaderList[4] = pWorld.shader("faceShader_4")  dieModel.shaderList[5] = pWorld.shader("faceShader_5")  dieModel.shaderList[6] = pWorld.shader("faceShader_2")  dieModel.translate(pX, pTileSize / 2, pZ)  boxModel2 = pWorld.newModel("nullObj", pWorld.modelResource("generic_cube"))  boxModel2.transform.scale = vector(0.5, 0.5, 0.5)  pPlayer = script("PlayerClass").new(pWorld, pBoard, pTileSize, die_face_up)  pActors.append(pPlayer)endon spinCamera me  gCameraScript = script("SpinCameraClass").new(pWorld.camera[1], pWorld.model("cameraNull"))endon spawnParticles me  particleResource = pWorld.newModelResource("particle system", #particle)  star_image = member("star", "art").image.duplicate()  pWorld.newTexture("particleTexture", #fromImageObject, star_image)  particleResource.texture = pWorld.texture("particleTexture")  particleResource.lifeTime = 1000.0  particleResource.sizeRange.start = 25  particleResource.sizeRange.end = 100  particleResource.blendRange.start = 100.0  particleResource.blendRange.end = 90.0  particleResource.emitter.distribution = #gaussian  particleResource.emitter.angle = 0  particleResource.emitter.numParticles = 3  particleResource.emitter.direction = vector(0, 1, 0)  particleResource.emitter.minSpeed = 150  particleResource.emitter.maxSpeed = 200  particleSystem = pWorld.newModel("particle system", particleResource)  exitTile = me.getExitTile()  pos = exitTile.transform.position  particleSystem.transform.position = vector(pos.x, pos.y, pos.z)endon playeronwarp me, warploc  grid_loc = value(warploc)  if pFlipX then    player_x = (pNumCols - grid_loc[1]) * pTileSize  else    player_x = (grid_loc[1] - 1) * pTileSize  end if  player_z = (grid_loc[2] - 1) * pTileSize  player_y = pPlayer.pmodel.transform.position.y  pPlayer.pmodel.transform.position = vector(player_x, player_y, player_z)endon playerOnSwitch me, switchType, sprite_member  ground_shader = pWorld.shader("groundShader")  sprite_member.shaderList = ground_shader  max = pSpikeList.count  repeat with x = 1 to max    Tile = pSpikeList[x]    if Tile.getSwitchGroup() = switchType then      Tile.retract()    end if  end repeatendon removetile me, whichtile  whichtile.removeFromWorld()endon reachedGoal me  sound(2).play(member("goalSound", "sounds"))  me.stopActors()  if pRoundScore < 0 then    pRoundScore = 0  end if  me.changeScoreBy(pRoundScore)  pTimeBonus = integer(pTimer.getNumSecondsLeft() / 3)  me.changeScoreBy(pTimeBonus)  gScoreboard.updateScore()  pprompt.drawPrompt(1)  me.spinCamera()  promptScript = script("PrompInput").new(me)  me.spawnParticles()endon playerdeath me  me.stopActors()  plives = plives - 1  gScoreboard.updatelives()  if plives <= 0 then    me.setEndGameText("no_lives")    me.stopActors()    me.gameover()    me.endgame()    go("gameoverframe")    return   end if  level_map = me.getmap()  me.setupBoard(level_map)endon setupBoard me, currentMap  pWorld.resetWorld()  pRoundScore = 100  pTimer = script("TimerClass").new(pTimeLimit, me)  pActors.append(pTimer)  overlay_Texture = member("prompt_overlay", "art")  sbImage = overlay_Texture.image.duplicate()  t1 = pWorld.newTexture("cameraTex", #fromImageObject, sbImage)  t1.renderFormat = #rgba4444  pprompt = script("PromptClass").new(sbImage, pWorld.camera[1], t1, me)  pTileSize = 100  boxResource = pWorld.newModelResource("generic_cube", #box)  boxResource.bottom = 0  boxResource.width = pTileSize  boxResource.height = pTileSize  boxResource.length = pTileSize  dieresource = pWorld.newModelResource("die_cube", #box)  dieresource.width = pTileSize  dieresource.height = pTileSize  dieresource.length = pTileSize  cylResource = pWorld.newModelResource("generic_cylinder", #cylinder)  cylResource.bottomRadius = 45  cylResource.height = pTileSize / 4  cylResource.topRadius = 45  cylResource = pWorld.newModelResource("generic_sphere", #sphere)  particleResource = pWorld.newModelResource("warp_particles", #particle)  particleResource.texture = pWorld.texture("particleTexture")  particleResource.lifeTime = 500  particleResource.emitter.loop = 1  particleResource.colorRange.start = rgb(23, 216, 23)  particleResource.colorRange.end = rgb(0, 255, 0)  particleResource.blendRange.start = 0.0  particleResource.blendRange.end = 50.0  particleResource.sizeRange.start = 25  particleResource.sizeRange.end = 0  particleResource.emitter.angle = 0  particleResource.emitter.distribution = #gaussian  particleResource.emitter.numParticles = 500  particleResource.emitter.direction = vector(0, 1, 0)  particleResource.emitter.minSpeed = 0  particleResource.emitter.maxSpeed = 500  particleResource.emitter.region = [vector(-50, 0, -50), vector(50, 0, -50), vector(-50, 0, 50), vector(50, 0, 50)]  lavaresource = pWorld.newModelResource("lava_particles", #particle)  lavaresource.texture = pWorld.texture("lava_texture")  lavaresource.lifeTime = 500  lavaresource.emitter.loop = 1  lavaresource.colorRange.start = rgb(255, 0, 0)  lavaresource.colorRange.end = rgb(255, 255, 0)  lavaresource.blendRange.start = 0.0  lavaresource.blendRange.end = 50.0  lavaresource.sizeRange.start = 15  lavaresource.sizeRange.end = 0  lavaresource.emitter.angle = 0  lavaresource.emitter.distribution = #linear  lavaresource.emitter.numParticles = 40  lavaresource.emitter.direction = vector(0, 1, 0)  lavaresource.emitter.minSpeed = 0  lavaresource.emitter.maxSpeed = 50  lavaresource.emitter.region = [vector(-50, 0, -50), vector(50, 0, -50), vector(-50, 0, 50), vector(50, 0, 50)]  setdiefacetextures()  ncg = pWorld.newGroup("nonCollide")  main_camera = pWorld.camera[1]  main_camera.projection = #orthographic  main_camera.orthoHeight = 1000  main_camera.transform.position = vector(870.42970000000002528, 1185.75, 870.42970000000002528)  main_camera.transform.rotation = vector(-45, 45, 0)  main_camera.hither = 1.0  main_camera.yon = 12000.0  cameraNull = pWorld.newModel("cameraNull", pWorld.modelResource("generic_cube"))  cameraNull.visibility = #none  cameraNull.translate(pTileSize * 3, pTileSize / 2, pTileSize * 3)  main_camera.parent = cameraNull  cameraNull.parent = ncg  me.setCameraView()  div = pMaxLevels / 3  bg_num = (pLevel / div) + 1  if bg_num > 3 then    bg_num = 3  end if  mem_name = "camera_bg" & bg_num  src_image = member(mem_name, "art").image  backdrop_texture = image(movieWidth, movieHeight - 100, 16)  dest_rect = rect(0, 0, movieWidth, movieHeight)  src_rect = rect(0, 100, src_image.width, src_image.height)  backdrop_texture.copyPixels(src_image, dest_rect, src_rect)  b1 = pWorld.newTexture("cameraBackdrop", #fromImageObject, backdrop_texture)  main_camera.addBackdrop(b1, point(0, 0), 0)  sprite_num = 2  gshowretry = plives > 1  gScoreboard = script("ScoreboardClass").new(sprite_num, src_image, gshowretry)  pWorld.light("UIDirectional").removeFromWorld()  pWorld.light("UIAmbient").removeFromWorld()  pWorld.newLight("directional_1", #directional)  obj = pWorld.light("directional_1")  obj.transform.position = vector(-442, 800, 444)  obj.transform.rotation = vector(-45.0, -45.0, 0.0)  obj.attenuation = vector(0.10000000000000001, 0, 0)  pWorld.newLight("directional_2", #directional)  obj = pWorld.light("directional_2")  obj.transform.position = vector(431, 800, 429)  obj.transform.rotation = vector(-45.0, 45.0, 0.0)  obj.attenuation = vector(0.10000000000000001, 0, 0)  pNumRows = currentMap.count  pNumCols = currentMap[1].count  tileWidth = 100  pX = 0  pZ = 0  plainwhiteshader = pWorld.newShader("shader_white", #standard)  plainwhitetexture = pWorld.newTexture("texture_white", #fromImageObject, pplainwhitetexture)  plainwhiteshader.texture = plainwhitetexture  plainwhiteshader.blend = 70  plainwhiteshader.emissive = rgb(255, 255, 255)  groundShader = pWorld.newShader("groundShader", #standard)  groundTexture = pWorld.newTexture("ground_texture", #fromImageObject, pgroundtexture)  if gDrawWireMode then    groundShader.renderStyle = #wire  end if  groundShader.texture = groundTexture  pWorld.shader("groundShader").shininess = 0  triggerShader = pWorld.newShader("triggerShader", #standard)  triggerTexture = pWorld.newTexture("trigger_texture", #fromImageObject, ptriggertexture)  triggerShader.texture = triggerTexture  triggerShader.blend = 70  triggerShader.emissive = rgb(0, 0, 255)  falltileshader = pWorld.newShader("fallTileShader", #standard)  falltiletexture = pWorld.newTexture("fallingTile_texture", #fromImageObject, pfalltiletexture)  falltileshader.texture = falltiletexture  woodShader = pWorld.newShader("woodShader", #standard)  woodTexture = pWorld.newTexture("wood_texture", #fromImageObject, pwoodtexture)  woodShader.texture = woodTexture  deathtileshader = pWorld.newShader("deathtileShader", #standard)  deathtiletexture = pWorld.newTexture("deathTile_texture", #fromImageObject, pdeathtiletexture)  deathtileshader.texture = deathtiletexture  deathtileshader.blend = 100  deathtileshader.shininess = 0  floortilescale = 1  if (pFlipZ = 1) and (pFlipX = 1) then    map_z = pNumRows    map_x = pNumCols  else    if pFlipZ = 1 then      map_z = pNumRows      map_x = 1    else      if pFlipX = 1 then        map_z = 1        map_x = pNumCols      else        map_z = 1        map_x = 1      end if    end if  end if  repeat with z = 1 to pNumRows    pBoard[z] = []    repeat with x = 1 to pNumCols      tile_spot = currentMap[map_z][map_x]      tileValue = tile_spot.t      case tileValue of        1:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = groundShader          t = script("PlainTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1)        2:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          wallHeight = tile_spot.h          Tile.shaderList = groundShader          Tile.transform.scale = vector(1, wallHeight * floortilescale, 1)          t = script("PlainTile3D").new(pX, ((tileWidth / 2 * wallHeight) - tileWidth) * floortilescale, pZ, Tile, tileValue, 0)        3:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.parent = ncg          Tile.transform.scale = vector(0.84999999999999998 * floortilescale, 0.84999999999999998 * floortilescale, 0.84999999999999998 * floortilescale)          goalShader = pWorld.newShader("goalShader", #standard)          faceNum = tile_spot.f          faceImage = member("die_" & faceNum, "3d Cast").image          exitImage = member("goal_tile", "3d Cast").image.duplicate()          exitImage = faceImage.duplicate()          exitImage.copyPixels(faceImage, exitImage.rect, faceImage.rect, [#ink: 36])          goalTexture = pWorld.newTexture("goalTexture", #fromImageObject, exitImage)          goalShader.texture = goalTexture          Tile.shaderList = plainwhiteshader          Tile.shaderList[5] = goalShader          goalShader.blend = 75          goalShader.emissive = rgb(255, 255, 255)          t = script("GoalTile3D").new(pX, pTileSize / 2, pZ, Tile, tileValue, 1, faceNum, me)          me.setExitTile(Tile)          Tile = pWorld.newModel("floorTile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = groundShader          plain_tile = script("PlainTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1)        4:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          switchShader = pWorld.newShader("switch_shader_" & z & "-" & x, #standard)          faceNum = tile_spot.f          switchImage = member("triggerTile", "3d Cast").image.duplicate()          faceImage = member("die_" & faceNum, "3d Cast").image          switchImage.copyPixels(faceImage, switchImage.rect, faceImage.rect, [#ink: 36])          switchTexture = pWorld.newTexture("switch_texture_" & z & "-" & x, #fromImageObject, switchImage)          switchShader.texture = switchTexture          Tile.shaderList = triggerShader          Tile.shaderList[5] = switchShader          switchSet = tile_spot.s          t = script("SwitchTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1, switchSet, faceNum, me)        5:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.shaderList = triggerShader          switchSet = tile_spot.s          t = script("SpikeTile3D").new(pX, tileWidth / 2, pZ, Tile, tileValue, 0, switchSet)          pSpikeList.append(t)          pActors.append(t)        6:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = deathtileshader          t = script("DeathTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1)          lavaparticles = pWorld.newModel("lava_particle" & z & "-" & x, lavaresource)          lavaparticles.parent = ncg          lavaparticles.transform.position = vector(pX, 0, pZ)        7:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = falltileshader          t = script("FallingTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1, me)          pActors.append(t)        8:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.parent = ncg          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = groundShader          warpblock = tile_spot.w          put "warpblock" && ilk(warpblock)          t = script("WarpTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1, warpblock, me)          warp_particles = pWorld.newModel("particle_warp_" & z & "-" & x, particleResource)          warp_particles.parent = ncg          pos = value(warpblock)          loc_x = (pos[1] - 1) * pTileSize          loc_z = (pos[2] - 1) * pTileSize          warp_particles.transform.position = vector(pX, 0, pZ)        9:          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cylinder"))          Tile.parent = ncg          weightedrandom = random(100)          if weightedrandom <= 60 then            coin_value = 5            coinfaceimage = pcointexture5          else            if weightedrandom <= 90 then              coin_value = 10              coinfaceimage = pcointexture10            else              coin_value = 25              coinfaceimage = pcointexture25            end if          end if          coinshader = pWorld.newShader("coinShader" & "-" & z & "-" & x, #standard)          coinshader.textureModeList[1] = #wrapPlanar          coinshader.wrapTransformList[1].rotate(90.0, 0.0, 180.0)          cointexture = pWorld.newTexture("coin_texture" & "-" & z & "-" & x, #fromImageObject, coinfaceimage)          coinshader.texture = cointexture          coinshader2 = pWorld.newShader("coinShader2" & "-" & z & "-" & x, #standard)          coinshader2.textureModeList[1] = #wrapPlanar          cointexture2 = pWorld.newTexture("coin_texture2" & "-" & z & "-" & x, #fromImageObject, coinfaceimage)          coinshader2.texture = cointexture2          coinshader2.wrapTransformList[1].rotate(90.0, 0.0, 0.0)          Tile.transform.rotation = vector(-90, 0, 0)          Tile.transform.scale = vector(1, 0.40000000000000002, 1)          Tile.shaderList = coinshader          Tile.shaderList[2] = coinshader          Tile.shaderList[3] = coinshader2          t = script("Coin3DClass").new(pX, pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1, me, coin_value)          pActors.append(t)          Tile = pWorld.newModel("floorTile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = groundShader          tt = script("PlainTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1)        "P":          die_face_up = tile_spot.f          makePlayer(me, currentMap, pZ, pX, die_face_up)          Tile = pWorld.newModel("tile_" & z & "-" & x, pWorld.modelResource("generic_cube"))          Tile.transform.scale = vector(1, floortilescale, 1)          Tile.shaderList = groundShader          t = script("PlainTile3D").new(pX, -pTileSize / 2 * floortilescale, pZ, Tile, tileValue, 1)        otherwise:          Tile = VOID          t = VOID          nothing()      end case      if Tile <> VOID then        Tile.parent = ncg      end if      pBoard[z][x] = t      pX = pX + pTileSize      if pFlipX = 1 then        map_x = map_x - 1        next repeat      end if      map_x = map_x + 1    end repeat    pX = 0    if pFlipX = 1 then      map_x = pNumCols    else      map_x = 1    end if    pZ = pZ + pTileSize    if pFlipZ = 1 then      map_z = map_z - 1      next repeat    end if    map_z = map_z + 1  end repeat  pSpriteChannelNum = 1  puppetSprite(pSpriteChannelNum, 1)  pWorld.directToStage = 1  sprite(pSpriteChannelNum).member = pWorld  sprite(pSpriteChannelNum).width = movieWidth  sprite(pSpriteChannelNum).height = 360  sprite(pSpriteChannelNum).loc = point(movieWidth / 2, (360 / 2) + p3dworldy)  set the keyDownScript to "checkForCheats"endon doTopdownCamera me  main_camera = pWorld.camera[1]  main_camera.projection = #perspective  main_camera.transform.position.x = cameraNull.transform.position.x - 240  main_camera.transform.position.z = cameraNull.transform.position.z - 240  main_camera.transform.position.y = 1800  main_camera.transform.rotation = vector(-90, 0, 0)endon doIsoCamera me  pCameraMode = "iso"  main_camera = pWorld.camera[1]  main_camera.projection = #orthographic  main_camera.orthoHeight = 1000  main_camera.transform.position = vector(870.42970000000002528, 1185.75, 870.42970000000002528)  main_camera.transform.rotation = vector(-45, 45, 0)endon setCameraView me  if pCameraMode = "iso" then    me.doIsoCamera()  else    me.doTopdownCamera()  end ifendon toggleCameraView me  if pCameraMode = "iso" then    pCameraMode = "topdown"  else    pCameraMode = "iso"  end if  me.setCameraView()endon toggleWireframe me  gDrawWireMode = not gDrawWireMode  groundShader = pWorld.shader("groundShader")  if gDrawWireMode then    groundShader.renderStyle = #wire  else    groundShader.renderStyle = #fill  end if  put "gDrawWireMode? " && gDrawWireModeendon resetTimer me, which_cheat  if me.myCheat = "moretimeruki" then    if pTimerCheated = 0 then      pTimerCheated = 1      pTimer.resetTimer()    end if  else    if me.myCheat = "helpmeplease" then      if pHelpMe = 0 then        pHelpMe = 1        pTimer.resetTimer()      end if    end if  end ifendon retrypressed me  if plives > 1 then    sound(1).play(member("buttonSound", "sounds"))    pPlayer.death()  end ifendon gameover me  ggameover = 1  _DGSBIOS.sendGameTag("Game Finished")endon endgamepressed me  me.setEndGameText("user_quit")  sound(1).play(member("buttonSound", "sounds"))  me.stopActors()  me.gameover()  me.endgame()  go("gameoverframe")endon restartcode me  sound(1).play(member("buttonSound", "sounds"))  me.endgame()  restartGame()endon endgame me  put "GameClass.endGame()"  gScoreboard.Remove()  if gCameraScript <> VOID then    gCameraScript.stopStep()  end if  pWorld.directToStage = 0  pWorld.resetWorld()  puppetSprite(pSpriteChannelNum, 0)  sprite(pSpriteChannelNum).member = VOIDendon sendscorecode me  put "sendscorecode"  sound(1).play(member("buttonSound", "sounds"))  me.endgame()  go("gameoverframe")  updateStage()endon setEndGameText me, type_str  if type_str = "no_lives" then    hdr_str = "You Have No Lives Left"    body_str = "You Reached Level" && pLevel  else    if type_str = "beat_all" then      hdr_str = "You Cleared All Levels!"      body_str = EMPTY    else      hdr_str = EMPTY      body_str = "You Reached Level" && pLevel    end if  end if  str = "Game Over" & RETURN & hdr_str & RETURN & "Your Score:" && pScore & RETURN & body_str  member("end_of_game_txt", "art").text = strend